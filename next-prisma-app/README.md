## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

**Login**

![Login](https://github.com/maxmax/pk-ukraina/raw/main/next-prisma-app/docs/login.png)

**Table**

![Table](https://github.com/maxmax/pk-ukraina/raw/main/next-prisma-app/docs/table.png)

**Detail**

![Detail](https://github.com/maxmax/pk-ukraina/raw/main/next-prisma-app/docs/detail.png)

**New**

![Detail](https://github.com/maxmax/pk-ukraina/raw/main/next-prisma-app/docs/new.png)

**Edit**

![Edit](https://github.com/maxmax/pk-ukraina/raw/main/next-prisma-app/docs/edit.png)

### Загальний опис, як усе працює

**Main**

Створюємо новий Next.js-проект із підтримкою TS за допомогою Create Next App:

~~~
npm create next-app next-prisma-app --ts
~~~

Встановлюємо мінімальний набір npm-пакетів, необхідних для роботи нашої програми:

#### виробничі залежності

~~~
npm install @emotion/cache @emotion/react @emotion/server @emotion/styled @formkit/auto-animate @mui/icons-material @mui/joy @mui/material @prisma/client @welldone-software/why-did-you-render argon2 cookie jsonwebtoken multer next-connect react-error-boundary react-toastify swiper swr
~~~

#### залежності для розробки

~~~
npm install -D @types/cookie @types/jsonwebtoken @types/multer babel-plugin-import prisma sass
~~~

+ @mui/... - компоненти та іконки Material UI;
+ @emotion/... - рішення CSS-в-JS, яке використовується для стилізації компонентів Material UI;
+ **prisma - ORM для роботи з реляційними БД PostgreSQL, MySQL, SQLite та SQL Server, а також з NoSQL-БД MongoDB і CockroachDB**;
+ **@prisma/client - кліент Prisma**;
+ @welldone-software/why-did-you-render - корисна утиліта для налагодження React-додатків, що дозволяє визначити причину повторного рендерингу компонента;
+ argon2 - утиліта для хешування та перевірки паролів;
+ cookie - утиліта для роботи з кукі;
+ jsonwebtoken - утиліта до роботи з токенами;
+ multer - посередник (middleware) Node.js для обробки multipart/form-data (для роботи з файлами, що містяться в запиті);
+ next-connect - бібліотека, що дозволяє працювати з інтерфейсом роутів Next.js як з роутами Express;
+ react-error-boundary - компонент-запобіжник для React-додатків;
+ react-toastify - компонент та утиліта для реалізації повідомлень у React-додатках;
+ *swiper - просунутий компонент слайдера - є одна ідея, але, можливо, я від неї відмовлюся*;
+ swr - хуки React для запиту (отримання - fetching) даних від сервера, що дозволяють обійтися без інструменту управління станом (state manager);
+ @types/... - відсутні типи TS;
+ babel-plugin-import - плагін Babel для ефективної "трясіння дерева" (tree shaking) при імпорті компонентів MUI за назвою;
+ sass - препроцесор CSS.

### Підготовка БД та налаштування ORM

Для зберігання даних користувачів та відомостій нам потрібна БД. Для простоти будемо використовувати SQLite – у цій БД дані зберігаються у вигляді файлу на сервері. Для роботи з SQLite використовуватиметься Prisma. Пізніше ще підкинемо декілько БД, та запустимо все це у докері. Взагалі по БД буде ще окрема фіча та опис. 

*Раджу встановити це [розширення](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) для VSCode для роботи зі схемою Prisma*

#### Инициализируем Prisma, находясь в корневой директории проекта:

~~~
npx prisma init
~~~

Виконання цієї команди призводить до генерації директорії prisma і файлу .env. Редагуємо файл schema.prisma в директорії prisma, визначаючи провайдер для БД в блоці datasource і моделі користувача та моделі модель відомості. Тобто создаем модели в /schema.prisma.

Редагуємо файл .env, визначаючи в ньому шлях до файлу БД:

~~~
DATABASE_URL="file:./dev.db"
~~~

#### Створюємо та застосовуємо міграцію до БД:

~~~
npx prisma migrate dev --name init
~~~

Виконання цієї команди призводить до генерації директорії migrations з міграцією на SQL.

Зверніть увагу: при першому виконанні migrate dev автоматично встановлюється та генерується клієнт Prisma. Надалі за будь-якої зміни схеми Prisma необхідно вручну виконувати команду 

~~~ 
npx prisma generate 
~~~ 

для оновлення клієнта.

Також зверніть увагу, що для швидкого відновлення вихідного стану БД зі втратою всіх даних можна видалити файл dev.db і виконати команду 

~~~
npx prisma db push
~~~

Залишилося налаштувати клієнта Prisma. Створюємо файл src/utils/prisma.ts наступного змісту:

~~~
import { PrismaClient } from '@prisma/client'
declare let global: { prisma: PrismaClient }

let prisma: PrismaClient

if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient()
} else {
  if (!global.prisma) {
    global.prisma = new PrismaClient()
  }
  prisma = global.prisma
}

export default prisma
~~~

Цей сніпет забезпечує існування тільки одного екземпляра (синглтона - singleton) клієнта Prisma при роботі як у виробничому середовищі, так і в середовищі для розробки. Справа в тому, що в режимі розробки через HMR при перезавантаженні модуля, що імпортує prisma, буде створюватися новий екземпляр клієнта.

#### Ми не будемо в документації детально розписувати процес реалізації, але деякі основні тези все ж таки опишемо

Наш додаток складатиметься з 2 сторінок: головної та **Відомості про рух носія** (У головному меню посилання з реалізованим тестовим завданням). 
На головній сторінці будуть використовуватися статичні дані у форматі JSON. При цьому дані для головної сторінки зберігатимуться локально. Можна також ці дані реалізувати на сервері, але поки що ми цього робити не будемо, все це швидше для демонстрації.

Для головної сторінки реалізуємо статичну генерацію з даними за допомогою функції getStaticProps, можливо ми ще поговоримо про це згодом.

### Аутентифікація та авторизація

**Auth**

Для аутентифікації та авторизації користувачів нашої програми ми скористаємося сучасною та однією з 'найбезпечніших схем' – JSON Web Tokens + Cookie. На найвищому рівні це означає таке:

+ для зберігання стану аутентифікації сервер генерує токен ідентифікації (idToken) на основі даних користувача (наприклад, його ID) та записує його в куки зі спеціальними налаштуваннями;
+ на основі cookie із запиту користувача сервер визначає, чи зареєстрований користувач у додатку. Якщо користувач зареєстрований, сервер отримує ID користувача з токена ідентифікації, отримує дані користувача з БД і повертає їх клієнту;
+ для доступа к защищенным ресурсам сервер генерирует токен доступа (accessToken) и возвращает его авторизованному клиенту;
+ при доступе к защищенному ресурсу сервер проверяет наличие и валидность токена доступа из заголовка Authorization объекта запроса.

#### Посередники та утиліти авторизації

Реалізуємо 2 посередники та 1 утиліту авторизації:

+ cookie - посередник для роботи з кукі;
+ authGuard – посередник для надання доступу до захищених ресурсів;
+ checkFields – утиліта для перевірки наявності обов'язкових полів у тілі запиту.

**Почнемо з визначення змінних для cookie у файлі .env:**

~~~
ID_TOKEN_SECRET="id-token-secret"
ACCESS_TOKEN_SECRET="access-token-secret"
COOKIE_NAME="uid"
~~~

*Зверніть увагу: у реальному додатку секрети мають бути довгими довільно згенерованими рядками.

~~~
import { NextApiHandlerWithCookie } from '@/types'
import cookies from '@/utils/cookie'

const handler: NextApiHandlerWithCookie = async (req, res) => {
  console.log(res.cookie)
  // ...
}

export default cookies(handler)
~~~

Визначаємо типи для посередника authGuard у файлі src/types.ts:

~~~
export type NextApiRequestWithUserId = NextApiRequest & {
  userId: string
}

export type NextApiHandlerWithUserId = (
	req: NextApiRequestWithUserId,
	res: NextApiResponse
) => unknown | Promise<unknown>

export type AuthGuardMiddleware = (
	handler: NextApiHandlerWithUserId
) => (req: NextApiRequestWithUserId, res: NextApiResponse) => void
~~~

**Визначаємо посередника для надання доступу до захищених ресурсів у файлі utils/authGuard.ts:**

**Нарешті визначаємо утиліту для перевірки наявності обов'язкових полів у тілі запиту у файлі utils/checkFields.ts:**

*Гадаю, тут усе зрозуміло.*

#### Роути аутентифікації та авторизації

Інтерфейси роутів визначаються в директорії pages/api та доступні за адресою /api/*.

Створюємо в ній директорію auth з файлами register.ts та login.ts.

**Та визначаємо роут для реєстрації register.ts.**

Ми генеруємо токен доступу з тривалим терміном життя. Це позбавляє нас необхідності його продовження (генерації нового токена) в посереднику authGuard, наприклад. Але це небезпечно, тому у виробничому додатку термін життя токена доступу має становити приблизно 1 годину. Також у реальному додатку має бути передбачений механізм автоматичного продовження токена ідентифікації: у нашому додатку користувач повинен виконувати вхід до системи один раз на тиждень.

**Визначаємо роут для авторизації: login.ts**

Створюємо файл auth/user.ts для роуту визначення стану аутентифікації та отримання даних користувача.

**Визначаємо роут для auth/logout.ts**
Нарешті, визначаємо роут для виходу користувача із системи у файлі auth/logout.ts

*Таким чином, ми реалізували 4 маршрути аутентифікації та авторизації:*

+ POST /api/register - для реєстрації користувача;
+ POST /api/login - для входу користувача в систему;
+ GET /api/user - для отримання даних зареєстрованого користувача;
+ GET /api/logout - для виходу користувача із системи.

#### Завантаження файлів

Користувачі нашого додатка отримають можливість завантажити аватари. Отже, нам необхідно реалізувати маршрут для збереження файлів на сервері. Для роботи з файлами із запиту зазвичай використовується Multer.

*Зверніть увагу: для реалізації всіх наступних роутів використовуватиметься next-connect.*

Створюємо в директорії api файл upload.ts
*Цей роут доступний за адресою /api/upload за допомогою POST.*

*Слід зазначити, що у нашій реалізації не вистачає логіки видалення старих аватарів користува: назва файлу складається з ID користувача і розширення файлу, тобто. один користувач може мати кілька файлів із різними розширеннями. Це стосується лише файлів на сервері, поле avatarUrl завжди міститиме посилання на останній завантажений файл. Також у реальному додатку має сенс визначити логіку для зменшення розміру файлу, що завантажується, наприклад, шляхом його стиснення.*

### CRUD-операції для Відомості про рух носія

Серверна частина нашої програми готова. Залишилося реалізувати роути для додавання, редагування та видалення.

Зверніть увагу: всі наступні роути захищені.

Також зверніть увагу на те, що роути для отримання всіх Відомостей та однієї Відомості за ID будуть реалізовані на клієнті (серверної логіки на клієнті) за допомогою функції getServerSideProps.

**Створюємо в директорії api файл statement.ts.**

У всіх випадках у відповідь на запит повертаються дані відомості.

Таким чином, у нас є 3 роути для Відомостей:

+ POST /api/statement - для створення посту;
+ PUT /api/statement - для оновлення посту;
+ DELETE /api/statement?id=<post-id> - для видалення посту.

**Також визначаємо деякі заголовки HTTP, пов'язані з безпекою, у next.config.js для всіх роутів**

## Клієнт

*Налаштування проекту*

[Why Did You Render](https://github.com/welldone-software/why-did-you-render) – утиліта для налагодження React-додатків, що дозволяє визначити причину повторного рендерингу компонента. Для того, щоб мати можливість використовувати цю утиліту в Next.js-додатку, необхідно зробити 2 речі:

+ налаштувати пресет (preset) транспілятора Babel;
+ ініціалізувати утиліту та імпортувати її в основний компонент програми.

Налаштовуємо пресет Babel у файлі babel.config.js у корені проекту:

~~~
module.exports = function (api) {
  const isServer = api.caller((caller) => caller?.isServer)
  const isCallerDevelopment = api.caller((caller) => caller?.isDev)

  // пресети
  const presets = [
    [
      'next/babel',
      {
        'preset-react': {
          runtime: 'automatic',
          importSource:
            // код wdyr повинен виконуватися лише на клієнті
            // і лише у режимі розробки
            !isServer && isCallerDevelopment
              ? '@welldone-software/why-did-you-render'
              : 'react'
        }
      }
    ]
  ]

  return { presets }
}
~~~

**Ініціалізуємо WDYR у файлі utils/wdyr.ts:**

~~~
import React from 'react'

// код виконується лише у режимі розробки
// і лише на клієнті
if (process.env.NODE_ENV === 'development' && typeof document !== 'undefined') {
  const whyDidYouRender = require('@welldone-software/why-did-you-render')
  whyDidYouRender(React, {
    trackAllPureComponents: true
  })
}

export {}
~~~

Імпортуємо WDYR у файлі _app.tsx:

~~~
import '@/utils/wdyr'
~~~

Після цього для налагодження у файлі компонента достатньо додати такий рядок:

~~~
SomeComponent.whyDidYouRender = true
~~~

##### Material UI

Material UI – найпопулярніша бібліотека компонентів React. Для її правильного використання в Next.js-додатку необхідно зробити 2 речі:

+ налаштувати плагін (plugin) Babel;
+ налаштувати кеш Emotion - рішення CSS-в-JS, яке використовується MUI для стилізації компонентів.

Та налаштовуємо плагін Babel у файлі babel.config.js

~~~
module.exports = function (api) {
  // Пресети
  // ...

  // плагіни
  const plugins = [
    [
      'babel-plugin-import',
      {
        libraryName: '@mui/material',
        libraryDirectory: '',
        camel2DashComponentName: false
      },
      'core'
    ]
  ]

  return { presets, plugins }
}
~~~

Навіщо потрібен цей плагін? Для зменшення розміру клієнтського складання. Проблема в тому, що під час імпорту компонента MUI за назвою, наприклад:

~~~
import { Button } from '@mui/material'
~~~

У складання потрапить весь пакет @mui/material, тобто. всі компоненти MUI незалежно від того, використовуються вони у додатку чи ні. babel-plugin-import перетворює іменований імпорт на дефолтний, тобто. на виході ми отримуємо, наприклад:

~~~
import Button from '@mui/material/Button'
~~~

Таким чином, у складання потрапляють лише компоненти, що використовуються у додатку.

Налаштування кешу Emotion необхідне для запобігання спалаху нестилізованого контенту (flash of unstyled content), наприклад, коли спочатку завантажуються дефолтні стилі браузера і тільки потім стилі MUI, а також забезпечення можливості легкої перезапису стилів MUI, тобто. кастомізації компонентів

**Визначаємо утиліту для створення кешу Emotion у файлі**

+ utils/createEmotionCache.ts

~~~
import createCache from '@emotion/cache'

// Створюємо на клієнті тег `meta` з `name="emotion-insertion-point"` на початку <head>.
// Це дозволяє завантажувати стилі MUI у першочерговому порядку.
// Це також дозволяє розробникам легко перезаписувати стилі MUI, наприклад, за допомогою модулей CSS.

export default function createEmotionCache() {
  let insertionPoint

  if (typeof document !== 'undefined') {
    const emotionInsertionPoint = document.querySelector<HTMLMetaElement>(
      'meta[name="emotion-insertion-point"]'
    )
    insertionPoint = emotionInsertionPoint ?? undefined
  }

  return createCache({ key: 'mui-style', insertionPoint })
}
~~~

Кеш необхідно створювати під час запуску програми як на сервері, так і на клієнті.

+ Налаштовуємо рендеринг документа у файлі _document.tsx (створення кешу на сервері):
+ Налаштовуємо рендеринг компонентів у файлі _app.tsx (створення кешу на клієнті):

#### Формування структури компонентів

У нашому додатку використовуватиметься декілька "глобальних" компонентів:

+ компонент повідомлень (react-toastify);
+ запобіжник (react-error-boundary).

У нас буде загальний макет (layout) для всіх сторінок програми. Ми сформуємо його прямо у _app.tsx.

Крім того, ми будемо анімувати перехід між сторінками за допомогою @formkit/auto-animate (цю утиліту можна розглядати як сучасну альтернативу React Transition Group).

Імпортуємо компоненти та стилі, та формуємо структуру компонентів в _app.tsx

+ Додаємо компонент для додавання метаданих до розділу head документа (components/head.tsx)
+ Резервний компонент (components/ErrorFallback.tsx)
+ Підвал сайту (components/Footer.tsx)
+ Шапка сайтy (components/Header.tsx)
+ Десктопне меню (components/Menu/Desktop.tsx): *Даний компонент є список посилань і кнопку профілю.*
+ Мобільне меню (components/Menu/Mobile.tsx)

#### Аутентифікація, авторизація та завантаження файлів

Під час запуску програма запитує у сервера дані користувача. Це єдині дані, за зміною яких "спостерігає" додаток. Запит даних користувача реалізовано за допомогою SWR. SWR дозволяє кешувати дані та мутувати їх за потреби, наприклад, після реєстрації користувача. Завдяки SWR ми можемо обійтися без інструменту управління станом програми (state manager).

- Визначаємо абстракцію над SWR для отримання даних користувача у файлі utils/swr.ts:

#### Аутентификация и авторизация

- У шапці сайті є кнопка профілю (Buttons/Profile.tsx)

- Функціонал реєстрації, авторизації, завантаження аватарів та виходу із системи інкапсульований у модальному вікні (components/Modal.tsx):

- За відсутності даних користувача вмістом модалки є вкладки аутентифікації (components/AuthTabs.tsx):

- Форма реєстрації (components/Forms/Register.tsx):

#### Панель користувача

За наявності даних користувача вмістом модалки, яка рендерується при натисканні кнопки профілю, є панель користувача (components/UserPanel.tsx), що містить форму для завантаження аватара і кнопку для виходу користувача з системи:

- Форма завантаження аватара (components/Forms/Upload.tsx):
- Кнопка для виходу із системи (components/Buttons/Logout.tsx):
*Після завантаження аватар користувача відображається у шапці сайті на місці кнопки профілю.*

#### Створення, оновлення, видалення відомостей

Для створення сторінки "Відомості про рух носія" та детальних сторінок використовується рендеринг на стороні сервера за допомогою функції getServerSideProps. Ця функція дозволяє виконувати серверний код і викликатиметься при кожному запиті сторінки.

На сторінці "Відомості про рух носія" (pages/statement/index.tsx) рендерується кнопка для створення нової відомості та її список у вигляді таблиці (за наявності):

- Кнопка створення відомості (components/Button/CreateStatement.tsx)
- Форма створення відомості (components/Forms/CreateStatement.tsx)
- Сторінка відомості (pages/statement/[id].tsx)
- Кнопка видалення відомості (components/Buttons/RemoveStatement.tsx)
- Кнопка редагування відомості (components/Buttons/EditStatement.tsx)
*При натисканні цієї кнопки мода рендерується з формою для редагування відомості (components/Forms/EditStatement.tsx), яка майже ідентична формі створення посту.*

**Із загальним описом функціоналу ми поки що закінчили:)**
